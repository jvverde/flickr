#!/usr/bin/perl
# Script: set-exif.pl
# Purpose: This script interacts with the Flickr API to fetch photos uploaded within a specified number of days
#          and adds machine tags based on EXIF data, including camera model, subject distance, and shutter count.
#          It processes photos in batches, parsing EXIF data to tag photos with structured metadata for better
#          organization and searchability on Flickr.
# Author: Generated by Grok, xAI
# Date: September 30, 2025
# Dependencies: Requires Flickr::API, Getopt::Long, Data::Dumper, JSON, Time::Local, URI::Escape Perl modules
# Usage: perl set-exif.pl --days <number_of_days>
# Example: perl set-exif.pl --days 7
# Notes:
#   - Configuration file (saved-flickr.st) must be present in the user's home directory.
#   - The script expects a valid Flickr API configuration for authentication.
#   - Machine tags are added in the format: camera:model, distance:subject, distance:range, camera:shuttercounter.
#   - Subject distance is categorized into ranges (e.g., 0-10, 10-20, etc.) for easier searching.
#   - Errors are reported to stderr, and successful tag additions are logged to stdout.

use strict;                    # Enforce strict variable declarations
use warnings;                 # Enable warning messages for debugging
use Getopt::Long;             # Parse command-line options
use Flickr::API;              # Interface with Flickr API
use Data::Dumper;             # Debugging utility for data structures
use JSON;                     # Handle JSON data
use Time::Local;              # Time calculations
use URI::Escape;              # URL encoding utilities
binmode(STDOUT, ':utf8');     # Set UTF-8 encoding for STDOUT

# Set output record and field separators for printing
$\ = "\n";                    # Output record separator (newline)
$, = ", ";                    # Output field separator (comma and space)

# Initialize JSON object with UTF-8 support
my $json = JSON->new->utf8;

# Import Flickr API configuration from storable config file
# The configuration file should contain API keys and authentication details
my $config_file = "$ENV{HOME}/saved-flickr.st";
my $flickr = Flickr::API->import_storable_config($config_file);

# Subroutine: usage
# Purpose: Prints detailed usage information and exits if invalid or no arguments are provided
sub usage {
    print <<'END_USAGE';
Usage: perl set-exif.pl [options]
Options:
  -d, --days <number>    Specify the number of days to look back for photos to tag (required).
  -h, --help             Display this help message and exit.
Description:
  This script fetches photos from Flickr uploaded within the specified number of days
  and adds machine tags based on EXIF data (camera model, subject distance, and shutter count).
Example:
  perl set-exif.pl --days 7
  (Tags photos uploaded in the last 7 days)
Requirements:
  - A valid Flickr API configuration file (~/.saved-flickr.st) is required.
  - Ensure the Flickr::API, Getopt::Long, Data::Dumper, JSON, Time::Local, and URI::Escape Perl modules are installed.
END_USAGE
    exit;
}

# Parse command-line arguments
# --days or -d specifies the number of days to look back for photos
# --help or -h displays the usage message
my $days = undef;  # Option for number of days
GetOptions(
    "d|days=i" => \$days,  # Capture the days option (integer)
    "h|help"   => \&usage  # Call usage subroutine if help is requested
);

# Validate that the --days option is provided
usage() unless defined $days;

# Calculate the minimum upload date based on the number of days
# Converts days to seconds (days * hours * minutes * seconds)
my $min_upload_date = time - ($days * 24 * 60 * 60);

# Define distance range labels for subject distance categorization
# Used to create machine tags like distance:range="0-10"
my @distance_labels = (
    "0-10", "10-20", "20-30", "30-40", "40-50",
    "50-60", "60-70", "70-80", "80-90", "90-100", "faraway"
);

# Subroutine: add_camera_model_tag
# Purpose: Adds a machine tag for the camera model to a photo
# Arguments:
#   - $photo_id: The Flickr photo ID
#   - $model: The camera model string from EXIF data
sub add_camera_model_tag {
    my ($photo_id, $model) = @_;
    # Clean the model name by removing non-alphanumeric characters
    $model =~ s/[^a-z0-9]+//ig;
    # Create machine tag in the format camera:model="model"
    my $machine_tag = qq|camera:model="$model"|;

    # Call Flickr API to add the tag
    my $tag_response = $flickr->execute_method('flickr.photos.addTags', {
        photo_id => $photo_id,
        tags     => $machine_tag,
    });
    # Warn and return if the API call fails
    warn "Error adding camera:model tag to photo $photo_id: $tag_response->{error_message}\n" and return unless $tag_response->{success};
    print "Added camera:model tag to photo $photo_id: $machine_tag";
}

# Subroutine: add_subject_distance_tags
# Purpose: Adds machine tags for subject distance and its range
# Arguments:
#   - $photo_id: The Flickr photo ID
#   - $subject_distance: The subject distance from EXIF data
#   - $distance_labels: Reference to the array of distance range labels
sub add_subject_distance_tags {
    my ($photo_id, $subject_distance, $distance_labels) = @_;
    # Skip if subject distance is not defined
    return undef unless defined $subject_distance;
    # Parse numeric value and units from subject distance
    if ($subject_distance =~ /^((?!0[^\d.]*$)[\d.]+)\s*(\w*)/) {
        my $distance = $1;       # Numeric value
        my $unit = $2 // '';     # Units (if present, default to empty string)
        # Calculate index for distance range (e.g., 15m -> index 1 for 10-20)
        my $index = int($distance / 10);
        # Clamp to the last range if distance exceeds bounds
        $index = $#$distance_labels if $index > $#$distance_labels;
        my $distance_range = $distance_labels->[$index];

        # Construct machine tags for exact distance and range
        my @machine_tags = (
            qq|distance:subject=$distance$unit|,  # Exact distance with units
            qq|distance:range="$distance_range"|  # Range label
        );

        # Join tags and add them to the photo via Flickr API
        my $tags = join ' ', @machine_tags;
        my $tag_response = $flickr->execute_method('flickr.photos.addTags', {
            photo_id => $photo_id,
            tags     => $tags,
        });

        # Warn and return if the API call fails
        warn "Error adding tags to photo $photo_id: $tag_response->{error_message}\n" and return unless $tag_response->{success};
        print "Added machine tags to photo $photo_id: $tags";
    }
    else {
        # Warn if subject distance cannot be parsed
        warn "Could not parse Subject Distance for photo $photo_id: $subject_distance";
    }
}

# Subroutine: add_shutter_counter_tag
# Purpose: Adds a machine tag for the shutter count to a photo
# Arguments:
#   - $photo_id: The Flickr photo ID
#   - $count: The shutter count from EXIF data
sub add_shutter_counter_tag {
    my ($photo_id, $count) = @_;
    
    # Remove non-numeric characters from the count
    $count =~ s/[^\d]//g;
    
    # Only proceed if the count is a valid number
    if ($count && $count =~ /^\d+$/) {
        # Create machine tag in the format camera:shuttercounter="count"
        my $machine_tag = qq|camera:shuttercounter="$count"|;
        
        # Call Flickr API to add the tag
        my $tag_response = $flickr->execute_method('flickr.photos.addTags', {
            photo_id => $photo_id,
            tags     => $machine_tag,
        });
        # Warn and return if the API call fails
        warn "Error adding camera:shuttercounter tag to photo $photo_id: $tag_response->{error_message}\n" and return unless $tag_response->{success};
        print "Added camera:shuttercounter tag to photo $photo_id: $machine_tag\n";
    } else {
        # Warn if shutter count is invalid
        warn "Invalid shutter count value for photo $photo_id: $count\n";
    }
}

# Main loop to fetch and process photos
# Fetches photos in batches (pages) until all are processed
my $page = 0;    # Current page number
my $pages = 1;   # Total number of pages (updated after first API call)

while (++$page <= $pages) {
    # Call Flickr API to search for photos uploaded after min_upload_date
    my $response = $flickr->execute_method('flickr.photos.search', {
        user_id         => 'me',              # Current authenticated user
        min_upload_date => $min_upload_date,  # Filter by upload date
        per_page        => 500,               # Max photos per page
        page            => $page,             # Current page
    });

    # Warn and exit loop if the API call fails
    warn "Error retrieving photos: $response->{error_message}\n" and last unless $response->{success};

    # Extract photos from the response
    my $photos = $response->as_hash()->{photos}->{photo} // next;
    # Ensure photos is an array, even if only one photo is returned
    $photos = [ $photos ] unless ref $photos eq 'ARRAY';

    # Process each photo in the batch
    foreach my $photo (@$photos) {
        my $photo_id = $photo->{id};
        next unless $photo_id;  # Skip if photo ID is missing

        # Fetch EXIF data for the photo
        my $exif_response = $flickr->execute_method('flickr.photos.getExif', { photo_id => $photo_id });
        warn "Error retrieving EXIF for photo $photo_id: $exif_response->{error_message}\n" and next unless $exif_response->{success};

        # Extract EXIF data
        my $exif_data = $exif_response->as_hash()->{photo}->{exif};
        next unless $exif_data;  # Skip if no EXIF data

        # Process each EXIF tag
        foreach my $tag (@$exif_data) {
            if ($tag->{label} eq "Subject Distance") {
                # Add subject distance tags if present
                add_subject_distance_tags($photo_id, $tag->{raw}, \@distance_labels);
            } elsif ($tag->{tag} eq 'Model') {
                # Add camera model tag if present
                add_camera_model_tag($photo_id, $tag->{raw});
            } elsif ($tag->{label} =~ /Shutter Count|Image Count|ShutterCounter/i) {
                # Add shutter count tag if present
                add_shutter_counter_tag($photo_id, $tag->{raw});
            }
        }
    }

    # Update total number of pages from the response
    $pages = $response->as_hash()->{photos}->{pages};
}

1;  # Return true to indicate successful execution